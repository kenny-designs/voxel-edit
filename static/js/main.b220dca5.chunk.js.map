{"version":3,"sources":["components/Viewport.jsx","components/BrushActions.jsx","components/BrushTypes.jsx","components/SubmitTextModal.jsx","components/File.jsx","components/Render.jsx","components/Examples.jsx","components/GitHubLink.jsx","components/ColorPalette.jsx","components/GUIController.jsx","modules/VoxelWorld.js","modules/Brush.js","modules/ColorPalette.js","modules/VoxelsEditor.js","components/VoxelManager.jsx","components/App.jsx","index.js"],"names":["Viewport","props","canvasRef","React","createRef","this","callbacks","onCanvasCreation","className","ref","Component","BrushActions","handleBrushClick","e","name","setState","activeBrushAction","onBrushActionChange","onGetBrushAction","state","Fragment","Menu","Item","active","onClick","BrushTypes","activeBrushType","onBrushTypeChange","onGetBrushType","SubmitTextModal","handleInputChange","value","target","trim","length","maxNameLength","inputValue","onSubmit","createModal","isInputEmpty","Modal","onClose","onOpen","open","closeIcon","size","Header","header","Content","Input","action","content","submit","disabled","fluid","onChange","error","placeholder","File","handleSaveProject","filename","projectJSON","JSON","stringify","onGetProjectData","blob","Blob","type","FileSaver","saveAs","isSaveModalOpen","onLoadProject","loadFileInput","click","handleFileSelected","file","files","loadFileReader","readAsText","saveInputValue","replace","handleFileRead","projectData","parse","result","onLoadProjectData","createExportModal","isExportModalOpen","onExportModel","exportType","createSaveModal","createExportSubMenu","Dropdown","text","pointing","document","createElement","accept","addEventListener","FileReader","onNewProject","Render","onExportImage","createExportImageModal","Examples","handleLoadExample","fileLocation","process","isLoading","fetch","then","res","json","createExampleProjectMenu","exampleProjects","map","project","createLoadScreen","basic","Loader","GitHubLink","href","Icon","ColorCell","color","id","isActive","getRGB255","r","g","b","onColorCellClick","style","backgroundColor","ColorPalette","updateColorData","onGetColorData","currentColor","selectedColorIndex","isColorsFull","newState","Object","keys","handlePickerChange","rgb","onSelectedColorChange","onNewSelectedColor","onAddCellClick","onAddColor","getColorCells","buttons","colors","forEach","index","push","getAddColorCell","disableAlpha","GUIController","updateMobileState","isMobile","window","innerWidth","handleAccordionIndicesChange","componentName","desktop","activeAccordionIndices","pos","indexOf","splice","createDesktopBrush","brushSettings","Segment","Group","inverted","as","Subheader","Accordion","exclusive","Title","includes","titleProps","vertical","brush","brushActions","brushTypes","createDesktopColorPalette","colorPalette","mobile","isModalOpen","modalContentType","removeEventListener","viewport","Grid","padded","height","Row","paddingTop","paddingBottom","Column","render","examples","width","overflowY","createDesktopViewport","prevState","createMobileModalContent","Actions","Button","primary","description","scrolling","Description","createMobileModal","innerHeight","fixed","overflowX","createMobileGUI","createDesktopGUI","VoxelWorld","options","cellSize","tileSize","tileTextureWidth","tileTextureHeight","material","cellSliceSize","cells","cellIdToMesh","neighborOffsets","x","y","z","voxelX","THREE","euclideanModulo","cellX","Math","floor","cellY","cellZ","cellId","computeCellId","cell","Uint8Array","v","addCell","getCellForVoxel","addCellForVoxel","voxelOffset","computeVoxelOffset","startX","startY","startZ","normX","normY","normZ","isExtruding","startVoxel","getVoxel","stack","pop","setVoxel","positions","normals","uvs","indices","voxelY","voxelZ","voxel","uvVoxel","faces","dir","corners","uvRow","ndx","uv","getColorAtIndex","start","end","dx","dy","dz","lenSq","len","sqrt","t","ix","iy","iz","stepX","stepY","stepZ","txDelta","abs","tyDelta","tzDelta","xDist","yDist","zDist","txMax","Infinity","tyMax","tzMax","steppedIndex","position","normal","scene","updatedCellIds","offset","ox","oy","oz","updateCellGeometry","mesh","geometry","generateGeometryDataForCell","setAttribute","Float32Array","setIndex","computeBoundingSphere","add","set","cellKeys","regex","cellKey","match","parseInt","dispose","remove","Brush","setCurrentAction","setCurrentType","currentAction","brushAction","currentType","brushType","paint","single","extrude","selectedColor","setNewColorsArray","Color","setSelectedColor","maxColors","newColors","createFlatGround","world","VoxelEditor","renderRequested","undefined","resizeRendererToDisplaySize","renderer","camera","aspect","canvas","clientWidth","clientHeight","updateProjectionMatrix","controls","update","requestRenderIfNotRequested","requestAnimationFrame","singleBrushAction","intersection","voxelId","getSelectedColorIndex","updateVoxelGeometry","extrudeBrushAction","floodFillVoxels","updateWorldGeometry","recordStartPosition","event","mouse","clientX","clientY","moveX","moveY","recordMovement","placeVoxelIfNoMovement","placeVoxel","setColorAtIndex","voxelWorld","getColorsArray","removeAllCells","imageName","toBlob","exporter","blobType","OBJExporter","PLYExporter","STLExporter","ColladaExporter","restoreDefaults","antialias","createCamera","createOrbitControls","background","addLight","side","alphaTest","transparent","vertexColors","preventDefault","passive","fov","near","far","OrbitControls","light","domElement","needResize","setSize","rect","getBoundingClientRect","left","top","getCanvasRelativePosition","setFromMatrixPosition","matrixWorld","unproject","intersectRay","VoxelManager","createVoxelWorld","voxelEditor","current","setBrushAction","getCurrentAction","setBrushType","getCurrentType","getSelectedColor","addColor","forceUpdate","getCallbacksObject","App","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.b220dca5.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./Viewport.css\";\n\n/**\n * Handles the 3D viewport and surrounding GUI for the application.\n * @property {Ref} canvasRef - Reference to the canvas\n *\n * @extends React.Component\n */\nclass Viewport extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // Reference to canvas element\n    this.canvasRef = React.createRef();\n  }\n\n  componentDidMount() {\n    // Canvas is ready to be drawn on\n    this.props.callbacks.onCanvasCreation(this.canvasRef);\n  }\n\n  render() {\n    return <canvas className=\"viewportCanvas\" ref={this.canvasRef} />;\n  }\n}\n\nexport default Viewport;\n","import React from \"react\";\nimport { Menu } from \"semantic-ui-react\";\n\n/**\n * Allows user to switch between brush actions add, remove, and paint.\n * @extends React.Component\n */\nclass BrushActions extends React.Component {\n  constructor(props) {\n    super(props);\n\n    const activeBrushAction = this.props.callbacks.onGetBrushAction();\n\n    this.state = {\n      activeBrushAction,\n    };\n  }\n\n  componentDidMount() {\n    // Send the initial brush action to parent component\n    //this.props.callbacks.onBrushActionChange(this.state.activeBrushAction);\n\n    const activeBrushAction = this.props.callbacks.onGetBrushAction();\n    this.setState({ activeBrushAction });\n  }\n\n  /**\n   * Handler for each brush action option. Upon click, updates the current\n   * brush action.\n   * @param {Event} e - React's original SyntheticEvent\n   * @param {data} props - Prop data from the Menu.Item\n   */\n  handleBrushClick = (e, { name }) => {\n    // Update state with new brush action\n    this.setState({ activeBrushAction: name });\n\n    // Send active brush action to parent component\n    this.props.callbacks.onBrushActionChange(name);\n  };\n\n  render() {\n    const { activeBrushAction } = this.state;\n\n    return (\n      <React.Fragment>\n        <Menu.Item\n          name=\"add\"\n          active={activeBrushAction === \"add\"}\n          onClick={this.handleBrushClick}\n        >\n          Add Voxel\n        </Menu.Item>\n        <Menu.Item\n          name=\"remove\"\n          active={activeBrushAction === \"remove\"}\n          onClick={this.handleBrushClick}\n        >\n          Remove Voxel\n        </Menu.Item>\n        <Menu.Item\n          name=\"paint\"\n          active={activeBrushAction === \"paint\"}\n          onClick={this.handleBrushClick}\n        >\n          Paint Voxel\n        </Menu.Item>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default BrushActions;\n","import React from \"react\";\nimport { Menu } from \"semantic-ui-react\";\n\n/**\n * Allows user to switch between brush types single and extrude.\n * @extends React.Component\n */\nclass BrushTypes extends React.Component {\n  constructor(props) {\n    super(props);\n\n    const activeBrushType = this.props.callbacks.onGetBrushType();\n\n    this.state = {\n      activeBrushType,\n    };\n  }\n\n  componentDidMount() {\n    // Send the initial brush type to parent component\n    // this.props.callbacks.onBrushTypeChange(this.state.activeBrushType);\n\n    const activeBrushType = this.props.callbacks.onGetBrushType();\n    this.setState({ activeBrushType });\n  }\n\n  /**\n   * Handler for each brush type option. Upon click, updates the current\n   * brush type.\n   * @param {Event} e - React's original SyntheticEvent\n   * @param {data} props - Prop data from the Menu.Item\n   */\n  handleBrushClick = (e, { name }) => {\n    // Update state with new brush type\n    this.setState({ activeBrushType: name });\n\n    // Send active brush type to parent component\n    this.props.callbacks.onBrushTypeChange(name);\n  };\n\n  render() {\n    const { activeBrushType } = this.state;\n\n    return (\n      <React.Fragment>\n        <Menu.Item\n          name=\"single\"\n          active={activeBrushType === \"single\"}\n          onClick={this.handleBrushClick}\n        >\n          Single Voxel\n        </Menu.Item>\n        <Menu.Item\n          name=\"extrude\"\n          active={activeBrushType === \"extrude\"}\n          onClick={this.handleBrushClick}\n        >\n          Extrude Voxel\n        </Menu.Item>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default BrushTypes;\n","import React from \"react\";\nimport { Modal, Input } from \"semantic-ui-react\";\n\n/**\n * Full page modal with a single controlled input and\n * a submit button.\n * @extends React.Component\n */\nclass SubmitTextModal extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      inputValue: \"\",\n    };\n\n    // Default max chars\n    this.maxNameLength = 100;\n  }\n\n  /**\n   * Handler for changes in the input.\n   * @function\n   * @param {Event} e\n   */\n  handleInputChange = (e) => {\n    let { value } = e.target;\n\n    // Trim any excess white-space\n    value = value.trim();\n\n    if (value.length <= this.maxNameLength) {\n      this.setState({ inputValue: value });\n    }\n  };\n\n  onSubmit = () => {\n    this.props.onSubmit(this.state.inputValue);\n  };\n\n  createModal = () => {\n    // True if empty, false otherwise\n    const isInputEmpty = this.state.inputValue.length === 0;\n\n    return (\n      <Modal\n        onClose={this.props.onClose}\n        onOpen={this.props.onOpen}\n        open={this.props.open}\n        closeIcon\n        size=\"mini\"\n      >\n        <Modal.Header>{this.props.header}</Modal.Header>\n        <Modal.Content>\n          <Input\n            action={{\n              content: this.props.submit,\n              disabled: isInputEmpty,\n              onClick: this.onSubmit,\n            }}\n            fluid\n            value={this.state.inputValue}\n            onChange={this.handleInputChange}\n            error={isInputEmpty}\n            placeholder={this.props.placeholder}\n          />\n        </Modal.Content>\n      </Modal>\n    );\n  };\n\n  render() {\n    return this.createModal();\n  }\n}\n\nexport default SubmitTextModal;\n","import React from \"react\";\nimport { Dropdown } from \"semantic-ui-react\";\nimport SubmitTextModal from \"./SubmitTextModal\";\nimport FileSaver from \"file-saver\";\n\n/**\n * Allows the user to perform file related actions such as save their\n * project or load one.\n * @TODO File is already a class used within the browser. Rename this! It might\n * be time to start referring to all components as just SomethingComponent or similar.\n *\n * @property {Input} loadFileInput - Input used for selecting project file to load\n * @property {FileReader} loadFileReader - Reads data from selected project file\n * @property {number} maxNameLength - Max chars a user can enter for their filename. Default 100\n * @extends React.Component\n */\nclass File extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      isSaveModalOpen: false,\n      isExportModalOpen: false,\n      exportType: \"\",\n    };\n\n    // Create input for allowing users to select their project to load\n    this.loadFileInput = document.createElement(\"input\");\n    this.loadFileInput.type = \"file\";\n    this.loadFileInput.accept = \".json\";\n    this.loadFileInput.addEventListener(\"change\", this.handleFileSelected);\n\n    // Create FileReader for loading user projects\n    this.loadFileReader = new FileReader();\n    this.loadFileReader.addEventListener(\"load\", this.handleFileRead);\n  }\n\n  /**\n   * Callback for when users wish to save their project. Creates a JSON file\n   * with the contents of the 3D scene then saves locally to the user's device.\n   * @function\n   * @param {string} filename What to name the saved project file\n   */\n  handleSaveProject = (filename) => {\n    // Prevent users from saving an empty filename\n    if (filename.length === 0) return;\n\n    // Get JSON that represents the project\n    const projectJSON = JSON.stringify(this.props.callbacks.onGetProjectData());\n\n    // Create the blob to download project json\n    let blob = new Blob([projectJSON], {\n      type: \"application/json\",\n    });\n\n    // Download it\n    FileSaver.saveAs(blob, filename + \".json\");\n\n    // Save complete, close modal\n    this.setState({ isSaveModalOpen: false });\n  };\n\n  /**\n   * Callback for when users wish to load a pre-existing project.\n   * @function\n   */\n  onLoadProject = () => {\n    this.loadFileInput.click();\n  };\n\n  /**\n   * Handler for when the users selects the file they wish to load.\n   * @function\n   * @param {Event} e\n   */\n  handleFileSelected = (e) => {\n    // Get the file to load\n    const file = this.loadFileInput.files[0];\n\n    // If no file found, return\n    if (!file) return;\n\n    // Read the file\n    this.loadFileReader.readAsText(file);\n\n    // Make the name of the file the new saveInputValue\n    const saveInputValue = file.name.replace(/(.json)$/, \"\");\n    this.setState({ saveInputValue });\n\n    // Reset value to empty string so that user can reload same file\n    this.loadFileInput.value = \"\";\n  };\n\n  /**\n   * Handler for reading the data from the user's selected project file.\n   * @function\n   * @param {Event} e\n   */\n  handleFileRead = (e) => {\n    // Convert JSON file into JavaScript object\n    const projectData = JSON.parse(e.target.result);\n\n    // Load project into the scene\n    this.props.callbacks.onLoadProjectData(projectData);\n  };\n\n  /**\n   * Creates the modal for when the user is exporting to some 3D object file.\n   * @function\n   * @returns {JSX}\n   */\n  createExportModal = () => {\n    return (\n      <SubmitTextModal\n        onClose={() => this.setState({ isExportModalOpen: false })}\n        onOpen={() => this.setState({ isExportModalOpen: true })}\n        open={this.state.isExportModalOpen}\n        onSubmit={this.onExportModel}\n        header=\"Export Model As...\"\n        submit={`Export .${this.state.exportType}`}\n        placeholder=\"Enter export name...\"\n      />\n    );\n  };\n\n  /**\n   * Creates the modal for when the user is saving their project.\n   * @function\n   * @returns {JSX}\n   */\n  createSaveModal = () => {\n    return (\n      <SubmitTextModal\n        onClose={() => this.setState({ isSaveModalOpen: false })}\n        onOpen={() => this.setState({ isSaveModalOpen: true })}\n        open={this.state.isSaveModalOpen}\n        onSubmit={this.handleSaveProject}\n        header=\"Save Project As...\"\n        submit=\"Save Project\"\n        placeholder=\"Enter project name...\"\n      />\n    );\n  };\n\n  /**\n   * Creates a sub-menu for each export option\n   * @function\n   * @returns {JSX}\n   */\n  createExportSubMenu = () => {\n    return (\n      <Dropdown text=\"Export\" pointing=\"left\" className=\"link item\">\n        <Dropdown.Menu>\n          <Dropdown.Item\n            onClick={() =>\n              this.setState({ isExportModalOpen: true, exportType: \"dae\" })\n            }\n          >\n            Collada (.dae)\n          </Dropdown.Item>\n\n          <Dropdown.Item\n            onClick={() =>\n              this.setState({ isExportModalOpen: true, exportType: \"ply\" })\n            }\n          >\n            Stanford (.ply)\n          </Dropdown.Item>\n\n          <Dropdown.Item\n            onClick={() =>\n              this.setState({ isExportModalOpen: true, exportType: \"stl\" })\n            }\n          >\n            Stl (.stl)\n          </Dropdown.Item>\n\n          <Dropdown.Item\n            onClick={() =>\n              this.setState({ isExportModalOpen: true, exportType: \"obj\" })\n            }\n          >\n            Wavefront (.obj)\n          </Dropdown.Item>\n        </Dropdown.Menu>\n      </Dropdown>\n    );\n  };\n\n  /**\n   * Hanlder for exporting the voxel model to some 3D file format.\n   * @function\n   * @param {string} filename Name of the exported 3D file\n   */\n  onExportModel = (filename) => {\n    // Export the model with the given filename and export type\n    this.props.callbacks.onExportModel(filename, this.state.exportType);\n\n    // Export complete, close modal\n    this.setState({ isExportModalOpen: false });\n  };\n\n  render() {\n    return (\n      <React.Fragment>\n        {this.createSaveModal()}\n        {this.createExportModal()}\n        <Dropdown text=\"File\" pointing className=\"link item\">\n          <Dropdown.Menu>\n            <Dropdown.Item onClick={this.props.callbacks.onNewProject}>\n              New Project\n            </Dropdown.Item>\n\n            <Dropdown.Item\n              onClick={() => this.setState({ isSaveModalOpen: true })}\n            >\n              Save Project\n            </Dropdown.Item>\n\n            <Dropdown.Item onClick={this.onLoadProject}>\n              Load Project\n            </Dropdown.Item>\n\n            {this.createExportSubMenu()}\n          </Dropdown.Menu>\n        </Dropdown>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default File;\n","import React from \"react\";\nimport { Dropdown } from \"semantic-ui-react\";\nimport SubmitTextModal from \"./SubmitTextModal\";\n\n/**\n * Allows the user to perform rendering related actions. Mostly, saving\n * their work to a .png file.\n *\n * @property {number} maxNameLength - Max chars a user can enter for their render file name\n * @extends React.Component\n */\nclass Render extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      isExportModalOpen: false,\n    };\n  }\n\n  /**\n   * Exports current frame of canvas to an image and closes the export modal.\n   * @function\n   * @param {string} filename What to name the saved image\n   */\n  onExportImage = (filename) => {\n    // Prevent empty filenames\n    if (filename.length === 0) return;\n\n    // Export the image\n    this.props.callbacks.onExportImage(filename);\n\n    // Close the modal\n    this.setState({ isExportModalOpen: false });\n  };\n\n  /**\n   * Creates the SubmitTextModal for the export image method.\n   * @function\n   * @returns {JSX}\n   */\n  createExportImageModal = () => {\n    return (\n      <SubmitTextModal\n        onClose={() => this.setState({ isExportModalOpen: false })}\n        onOpen={() => this.setState({ isExportModalOpen: true })}\n        open={this.state.isExportModalOpen}\n        onSubmit={this.onExportImage}\n        header=\"Export Image As...\"\n        submit=\"Export Image\"\n        placeholder=\"Enter image name...\"\n      />\n    );\n  };\n\n  render() {\n    return (\n      <React.Fragment>\n        {this.createExportImageModal()}\n        <Dropdown text=\"Render\" pointing className=\"link item\">\n          <Dropdown.Menu>\n            <Dropdown.Item\n              onClick={() => this.setState({ isExportModalOpen: true })}\n            >\n              Export Scene to Image\n            </Dropdown.Item>\n          </Dropdown.Menu>\n        </Dropdown>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default Render;\n","import React from \"react\";\nimport { Dropdown, Loader, Modal } from \"semantic-ui-react\";\n\n/**\n * Gives the user several example projects to load into their scene and\n * play with.\n * @property {Array.<Object>} exampleProjects - Example projects the user can load\n */\nclass Examples extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      isLoading: false,\n    };\n\n    // Array of projects that the user can load\n    // @TODO: It would be nice to automatically generate these from\n    // the models directory. If possible, try to make that happen\n    this.exampleProjects = [\n      { name: \"EarthBound\", filename: \"earthbound-voxel\" },\n      { name: \"Red Mage\", filename: \"redmage\" },\n      { name: \"Samus\", filename: \"samus-8bit\" },\n      { name: \"Super Meat Boy\", filename: \"super-meat-boy\" },\n      { name: \"Zombie\", filename: \"zombie-grave\" },\n    ];\n  }\n\n  /**\n   * Handler for when user wants to load an example project\n   * @function\n   */\n  handleLoadExample = (filename) => {\n    // Get the actual location of the file\n    const fileLocation =\n      process.env.PUBLIC_URL + \"/models/\" + filename + \".json\";\n\n    // Turn on the loader\n    this.setState({ isLoading: true });\n\n    // Fetch the file from the public directory\n    fetch(fileLocation)\n      .then((res) => {\n        return res.json();\n      })\n      // Obtained JSON of file, load the project\n      .then(this.props.callbacks.onLoadProjectData)\n      .then(() => this.setState({ isLoading: false }));\n  };\n\n  /**\n   * Generates each example project for the dropdown menu.\n   * @function\n   * @returns {JSX}\n   */\n  createExampleProjectMenu = () => {\n    // Return an array of JSX dropdown items\n    const items = this.exampleProjects.map((project) => {\n      // Get the name and filename of the current project\n      const { name, filename } = project;\n\n      // Generate a dropdown item based on the given name and filename\n      return (\n        <Dropdown.Item\n          key={name}\n          onClick={() => this.handleLoadExample(filename)}\n        >\n          {name}\n        </Dropdown.Item>\n      );\n    });\n\n    // Return final array of JSX dropdown items\n    return items;\n  };\n\n  /**\n   * Creates a load screen while loading in the chosen example project.\n   * @returns {JSX}\n   */\n  createLoadScreen = () => {\n    return (\n      <Modal basic open={this.state.isLoading}>\n        <Loader size=\"massive\">Loading project...</Loader>\n      </Modal>\n    );\n  };\n\n  render() {\n    return (\n      <React.Fragment>\n        {this.createLoadScreen()}\n        <Dropdown text=\"Examples\" pointing className=\"link item\">\n          <Dropdown.Menu>{this.createExampleProjectMenu()}</Dropdown.Menu>\n        </Dropdown>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default Examples;\n","import { Menu, Icon } from \"semantic-ui-react\";\n\n/**\n * Returns JSX with a link to the project's GitHub repo.\n * @TODO This component will likely be replaced when a Help dropdown is added.\n * Place the contents into there and remove this component when it is created.\n * @returns {JSX}\n */\nconst GitHubLink = () => {\n  return (\n    <Menu.Item\n      href=\"https://github.com/kenny-designs/voxel-edit\"\n      target=\"_blank\"\n    >\n      <Icon name=\"github\" />\n      GitHub\n    </Menu.Item>\n  );\n};\n\nexport default GitHubLink;\n","import React from \"react\";\nimport \"./ColorPalette.css\";\nimport { ChromePicker } from \"react-color\";\nimport { Icon } from \"semantic-ui-react\";\n\n/**\n * Represents each individual color on the color palette.\n * @param {*} props\n * @returns {JSX}\n */\nconst ColorCell = (props) => {\n  const { color, id, isActive } = props;\n  const { r, g, b } = color.getRGB255();\n\n  return (\n    <div\n      onClick={() => {\n        props.onColorCellClick(id, { r, g, b });\n      }}\n      className={`color-cell ${isActive ? \"active\" : \"\"}`}\n      style={{\n        backgroundColor: `rgb(${r}, ${g}, ${b})`,\n      }}\n    ></div>\n  );\n};\n\n/**\n * Allows the user to select what colors they wish to paint with,\n * choose new colors to paint with, and select the color that they\n * are currently painting with.\n * @extends React.Component\n */\nclass ColorPalette extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // Get data from parent component\n    const {\n      currentColor,\n      selectedColorIndex,\n      isColorsFull,\n    } = this.props.callbacks.onGetColorData();\n\n    this.state = {\n      currentColor,\n      selectedColorIndex,\n      isColorsFull,\n    };\n  }\n\n  /**\n   * Checks for changes in color data from the onGetColorData() prop. If\n   * there are any, updates the state.\n   */\n  updateColorData = () => {\n    const {\n      currentColor,\n      selectedColorIndex,\n      isColorsFull,\n    } = this.props.callbacks.onGetColorData();\n\n    let newState = {};\n\n    if (this.state.isColorsFull !== isColorsFull) {\n      newState.isColorsFull = isColorsFull;\n    }\n\n    if (this.state.selectedColorIndex !== selectedColorIndex) {\n      newState.selectedColorIndex = selectedColorIndex;\n    }\n\n    const { r, g, b } = this.state.currentColor;\n    if (r !== currentColor.r || g !== currentColor.g || b !== currentColor.b) {\n      newState.currentColor = currentColor;\n    }\n\n    if (Object.keys(newState).length !== 0) {\n      this.setState(newState);\n    }\n  };\n\n  componentDidUpdate() {\n    this.updateColorData();\n  }\n\n  /**\n   * Handles color picker change.\n   * @param {*} rgb\n   */\n  handlePickerChange = ({ rgb }) => {\n    // Tell the parent that there was a change in color\n    this.props.callbacks.onSelectedColorChange(\n      this.state.selectedColorIndex,\n      rgb\n    );\n\n    this.updateColorData();\n  };\n\n  /**\n   * Updates the currently selected color cell to the given id\n   * @param {number} id\n   * @param {string} color - Color of the cell\n   */\n  onColorCellClick = (id, color) => {\n    // Tell the parent that there is a new selected color/cell\n    this.props.callbacks.onNewSelectedColor(id);\n\n    this.updateColorData();\n  };\n\n  /**\n   * Handles when the add cell button is clicked.\n   */\n  onAddCellClick = () => {\n    // Add a new color to the palette\n    this.props.callbacks.onAddColor();\n\n    this.updateColorData();\n  };\n\n  /**\n   * Creates the JSX for all of the color select buttons.\n   * @returns {JSX}\n   */\n  getColorCells = () => {\n    // Create buttons for each color\n    let buttons = [];\n    const { colors } = this.props.callbacks.onGetColorData();\n    colors.forEach((color, index) => {\n      buttons.push(\n        <ColorCell\n          key={index}\n          id={index}\n          onColorCellClick={this.onColorCellClick}\n          color={color}\n          isActive={index === this.state.selectedColorIndex}\n        />\n      );\n    });\n\n    return buttons;\n  };\n\n  /**\n   * Creates the JSX for the add color cell. If the internal ColorPalette's\n   * colors array is full, returns null instead.\n   * @returns {JSX}\n   */\n  getAddColorCell = () => {\n    if (this.state.isColorsFull) return null;\n\n    return (\n      <div className=\"color-cell add-cell-btn\" onClick={this.onAddCellClick}>\n        <Icon name=\"plus\" />\n      </div>\n    );\n  };\n\n  render() {\n    return (\n      <div>\n        <div className=\"color-cell-container\">\n          {this.getColorCells()}\n          {this.getAddColorCell()}\n        </div>\n        <ChromePicker\n          color={this.state.currentColor}\n          disableAlpha={true}\n          onChange={this.handlePickerChange}\n        />\n      </div>\n    );\n  }\n}\n\nexport default ColorPalette;\n","import \"./GUIController.css\";\nimport React from \"react\";\nimport Viewport from \"./Viewport\";\nimport BrushActions from \"./BrushActions\";\nimport BrushTypes from \"./BrushTypes\";\nimport File from \"./File\";\nimport Render from \"./Render\";\nimport Examples from \"./Examples\";\nimport GitHubLink from \"./GitHubLink\";\nimport ColorPalette from \"./ColorPalette\";\nimport {\n  Modal,\n  Button,\n  Grid,\n  Segment,\n  Menu,\n  Accordion,\n  Header,\n  Icon,\n} from \"semantic-ui-react\";\n\n/**\n * Handles switching between both desktop and mobile versions of the\n * UI. Whenever one of its chidlren updates, it will pass that data\n * up to its parent component.\n * @extends React.Component\n */\nclass GUIController extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      isMobile: false,\n      mobile: {\n        isModalOpen: false,\n        modalContentType: \"\",\n      },\n      desktop: {\n        brushSettings: {\n          activeAccordionIndices: [0, 1],\n        },\n        colorPalette: {\n          activeAccordionIndices: [0],\n        },\n      },\n    };\n  }\n\n  /**\n   * Handler for screen resize events that updates whether or not the application\n   * should currently be using the mobile or desktop GUI.\n   */\n  updateMobileState = () => {\n    // If width below 768, use mobile GUI\n    const isMobile = window.innerWidth < 768;\n\n    this.setState({ isMobile });\n  };\n\n  /**\n   * Toggles the accordion at the given index for the given state with a\n   * activeAccordionIndices property.\n   * @param {number} index - Index of accordion to toggle\n   * @param {string} componentName - The state.desktop property with a activeAccordionIndices property\n   */\n  handleAccordionIndicesChange = (index, componentName) => {\n    // Make a copy of the desktop state object\n    const desktop = { ...this.state.desktop };\n\n    // Get the active indices for that component\n    const { activeAccordionIndices } = desktop[componentName];\n\n    // Get the position of the accordion index\n    const pos = activeAccordionIndices.indexOf(index);\n\n    // Position was found, remove the index for the user is closing the accordion\n    if (pos !== -1) {\n      activeAccordionIndices.splice(pos, 1);\n    }\n    // Position not found, add the index\n    else {\n      activeAccordionIndices.push(index);\n    }\n\n    // Update the state of the active indices for the given component\n    this.setState({ desktop });\n  };\n\n  componentDidMount() {\n    // Perform initial check for mobile device\n    this.updateMobileState();\n    window.addEventListener(\"resize\", this.updateMobileState);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(\"resize\", this.updateMobileState);\n  }\n\n  /**\n   * Creates the JSX for the desktop version of the viewport.\n   * @returns {JSX}\n   */\n  createDesktopViewport() {\n    return <Viewport callbacks={this.props.callbacks.viewport} />;\n  }\n\n  /**\n   * Creates the JSX for the desktop version of the brush.\n   * @returns {JSX}\n   */\n  createDesktopBrush = () => {\n    const { brushSettings } = this.state.desktop;\n\n    return (\n      <Segment.Group>\n        <Segment inverted>\n          <Header as=\"h4\" inverted>\n            <Icon name=\"paint brush\" />\n            <Header.Content>\n              Brush Settings\n              <Header.Subheader>Add, remove, or paint voxels</Header.Subheader>\n            </Header.Content>\n          </Header>\n\n          <Accordion inverted fluid exclusive={false}>\n            <Accordion.Title\n              active={brushSettings.activeAccordionIndices.includes(0)}\n              content=\"Brush Actions\"\n              index={0}\n              onClick={(e, titleProps) => {\n                this.handleAccordionIndicesChange(\n                  titleProps.index,\n                  \"brushSettings\"\n                );\n              }}\n            />\n            <Accordion.Content\n              active={brushSettings.activeAccordionIndices.includes(0)}\n            >\n              <Menu inverted vertical fluid>\n                <BrushActions\n                  callbacks={this.props.callbacks.brush.brushActions}\n                />\n              </Menu>\n            </Accordion.Content>\n          </Accordion>\n\n          <Accordion inverted fluid exclusive={false}>\n            <Accordion.Title\n              active={brushSettings.activeAccordionIndices.includes(1)}\n              content=\"Brush Types\"\n              index={1}\n              onClick={(e, titleProps) => {\n                this.handleAccordionIndicesChange(\n                  titleProps.index,\n                  \"brushSettings\"\n                );\n              }}\n            />\n            <Accordion.Content\n              active={brushSettings.activeAccordionIndices.includes(1)}\n            >\n              <Menu inverted vertical fluid>\n                <BrushTypes callbacks={this.props.callbacks.brush.brushTypes} />\n              </Menu>\n            </Accordion.Content>\n          </Accordion>\n        </Segment>\n      </Segment.Group>\n    );\n  };\n\n  /**\n   * Creates the JSX for the desktop version of the color palette.\n   * @returns {JSX}\n   */\n  createDesktopColorPalette = () => {\n    const { colorPalette } = this.state.desktop;\n\n    return (\n      <Segment.Group>\n        <Segment inverted>\n          <Header as=\"h4\" inverted>\n            <Icon name=\"tint\" />\n            <Header.Content>\n              Color Palette\n              <Header.Subheader>Select a color to paint with</Header.Subheader>\n            </Header.Content>\n          </Header>\n          <Accordion inverted fluid exclusive={false}>\n            <Accordion.Title\n              active={colorPalette.activeAccordionIndices.includes(0)}\n              content=\"Color Selection\"\n              index={0}\n              onClick={(e, titleProps) => {\n                this.handleAccordionIndicesChange(\n                  titleProps.index,\n                  \"colorPalette\"\n                );\n              }}\n            />\n            <Accordion.Content\n              active={colorPalette.activeAccordionIndices.includes(0)}\n            >\n              <ColorPalette callbacks={this.props.callbacks.colorPalette} />\n            </Accordion.Content>\n          </Accordion>\n        </Segment>\n      </Segment.Group>\n    );\n  };\n\n  /**\n   * Create the desktop version of the UI.\n   * @returns {JSX}\n   */\n  createDesktopGUI() {\n    return (\n      <Grid padded style={{ height: \"100vh\" }}>\n        <Grid.Row style={{ paddingTop: \"0\", paddingBottom: \"0\" }}>\n          <Grid.Column>\n            <Menu inverted>\n              <File callbacks={this.props.callbacks.file} />\n              {/*<Edit />*/}\n              <Render callbacks={this.props.callbacks.render} />\n              <Examples callbacks={this.props.callbacks.examples} />\n              <GitHubLink />\n            </Menu>\n          </Grid.Column>\n        </Grid.Row>\n\n        <Grid.Row\n          style={{ height: \"90%\", paddingTop: \"0\", paddingBottom: \"0\" }}\n        >\n          <Grid.Column\n            width={3}\n            style={{\n              height: \"100%\",\n              overflowY: \"auto\",\n            }}\n          >\n            {this.createDesktopBrush()}\n            {this.createDesktopColorPalette()}\n          </Grid.Column>\n\n          <Grid.Column width={13} style={{ height: \"100%\" }}>\n            {this.createDesktopViewport()}\n          </Grid.Column>\n\n          {/* Right Panel. Empty for now.*/}\n          {/* <Grid.Column width={2} style={{ height: \"100%\" }}></Grid.Column> */}\n        </Grid.Row>\n      </Grid>\n    );\n  }\n\n  /**\n   * Creates JSX for modals on mobile devices.\n   * @returns {JSX}\n   */\n  createMobileModal() {\n    return (\n      <Modal\n        className=\"mobileModal\"\n        open={this.state.mobile.isModalOpen}\n        onClose={() =>\n          this.setState((prevState) => ({\n            mobile: { ...prevState.mobile, isModalOpen: false },\n          }))\n        }\n        onOpen={() =>\n          this.setState((prevState) => ({\n            mobile: { ...prevState.mobile, isModalOpen: true },\n          }))\n        }\n      >\n        {/* Populate the modal with relevant content */}\n        {this.createMobileModalContent()}\n\n        <Modal.Actions>\n          <Button\n            onClick={() =>\n              this.setState((prevState) => ({\n                mobile: { ...prevState.mobile, isModalOpen: false },\n              }))\n            }\n            primary\n          >\n            Close\n          </Button>\n        </Modal.Actions>\n      </Modal>\n    );\n  }\n\n  /**\n   * Populates the mobile modal with content relevant to what the user selected.\n   * For example, opening the ColorPalette will fill the modal with ColorPalette\n   * related JSX.\n   * @returns {JSX}\n   */\n  createMobileModalContent() {\n    const { modalContentType } = this.state.mobile;\n\n    // Header and description of our modal\n    let header, description;\n\n    // Generate JSX based on the current modal type\n    switch (this.state.mobile.modalContentType) {\n      case \"ColorPalette\":\n        header = (\n          <Header as=\"h4\">\n            <Icon name=\"tint\" />\n            <Header.Content>\n              Color Palette\n              <Header.Subheader>Select a color to paint with</Header.Subheader>\n            </Header.Content>\n          </Header>\n        );\n        description = (\n          <ColorPalette callbacks={this.props.callbacks.colorPalette} />\n        );\n        break;\n\n      case \"BrushSettings\":\n        header = (\n          <Header as=\"h4\">\n            <Icon name=\"paint brush\" />\n            <Header.Content>\n              Brush Settings\n              <Header.Subheader>Add, remove, or paint voxels</Header.Subheader>\n            </Header.Content>\n          </Header>\n        );\n        description = (\n          <Menu inverted vertical fluid>\n            <Menu.Item header>Brush Actions</Menu.Item>\n            <BrushActions callbacks={this.props.callbacks.brush.brushActions} />\n            <Menu.Item header>Brush Types</Menu.Item>\n            <BrushTypes callbacks={this.props.callbacks.brush.brushTypes} />\n          </Menu>\n        );\n        break;\n\n      default:\n        header = \"Empty Modal\";\n        description = `Nothing in here. Thr current modal type is '${modalContentType}'`;\n    }\n\n    // Return JSX for the modal contents based on our header and description\n    return (\n      <React.Fragment>\n        <Modal.Header>{header}</Modal.Header>\n        <Modal.Content scrolling>\n          <Modal.Description>{description}</Modal.Description>\n        </Modal.Content>\n      </React.Fragment>\n    );\n  }\n\n  /**\n   * Create the mobile version of the UI.\n   * @returns {JSX}\n   */\n  createMobileGUI() {\n    return (\n      <React.Fragment>\n        {this.createMobileModal()}\n\n        <div style={{ height: window.innerHeight }}>\n          {/* Create top menu */}\n          <Menu fixed=\"top\" inverted>\n            <File callbacks={this.props.callbacks.file} />\n            {/*<Edit />*/}\n            <Render callbacks={this.props.callbacks.render} />\n            <Examples callbacks={this.props.callbacks.examples} />\n            <GitHubLink />\n          </Menu>\n\n          <Viewport callbacks={this.props.callbacks.viewport} />\n\n          {/* Create bottom menu */}\n          <Menu fixed=\"bottom\" inverted style={{ overflowX: \"auto\" }}>\n            <Menu.Item\n              as=\"a\"\n              onClick={() =>\n                this.setState({\n                  mobile: {\n                    isModalOpen: true,\n                    modalContentType: \"BrushSettings\",\n                  },\n                })\n              }\n            >\n              Brush Settings\n            </Menu.Item>\n\n            <Menu.Item\n              as=\"a\"\n              onClick={() =>\n                this.setState({\n                  mobile: {\n                    isModalOpen: true,\n                    modalContentType: \"ColorPalette\",\n                  },\n                })\n              }\n            >\n              Color Palette\n            </Menu.Item>\n          </Menu>\n        </div>\n      </React.Fragment>\n    );\n  }\n\n  render() {\n    return this.state.isMobile\n      ? this.createMobileGUI()\n      : this.createDesktopGUI();\n  }\n}\n\nexport default GUIController;\n","import * as THREE from \"three\";\n\n/**\n * Manages voxel data.\n * At the top level, a single VoxelWorld consists of cells. Each cell is a 'chunk' of the world\n * that consists of voxels (i.e. cubes). In order to optimize render times, we merge the geometry\n * of all the voxels within a single cell and make a single render call (as opposed to rendering\n * each individual voxel). In addition, a single cell is essentially a 3D grid that voxels are\n * placed in. Each cell has a length, width, and height dictated by the cellSize variable. This could\n * be set to anything but is perhaps best capped at 128 or 256 (256^3 is 16,777,216 voxels!).\n *\n * @property {number} cellSize      - The length, width, and height of a single cell (or chunk) within the world\n * @property {number} cellSliceSize - The area of a single slice of each cell (cellSize^2)\n * @property {Object} cells         - Object consisting of an array for each cell\n */\nclass VoxelWorld {\n  /**\n   * Creates a VoxelWorld object with the given options\n   * @param {Object} options - Options to spawn the world with\n   * @param {number} options.cellSize - The length, width, and height of each cell\n   * @param {number} options.tileSize - The size of each tile from a texture atlas\n   * @param {number} options.tileTextureWidth - The width of the texture atlas\n   * @param {number} options.tileTextureHeight - The height of the texture atlas\n   * @param {*} options.material - The material that the VoxelWorld should use for its meshes\n   * @param {ColorPalette} options.colorPalette- The current color palette that the world is using\n   */\n  constructor(options) {\n    this.cellSize = options.cellSize;\n    this.tileSize = options.tileSize;\n    this.tileTextureWidth = options.tileTextureWidth;\n    this.tileTextureHeight = options.tileTextureHeight;\n    this.material = options.material;\n    this.colorPalette = options.colorPalette;\n    this.cellSliceSize = this.cellSize * this.cellSize;\n    this.cells = options.cells;\n\n    // Used in the updateCellGeometry() function\n    // Tracks the meshes for each cell\n    this.cellIdToMesh = {};\n\n    // Used in updateVoxelGeometry() function\n    this.neighborOffsets = [\n      [0, 0, 0], // self\n      [-1, 0, 0], // left\n      [1, 0, 0], // right\n      [0, -1, 0], // down\n      [0, 1, 0], // up\n      [0, 0, -1], // back\n      [0, 0, 1], // front\n    ];\n  }\n\n  /**\n   * Returns the offset, or index, to the voxel within the cell array\n   * at the given x, y, and z coordinates.\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   * @returns {number} Index to the voxel within the cell array\n   */\n  computeVoxelOffset(x, y, z) {\n    const { cellSize, cellSliceSize } = this;\n\n    // Note, the \"| 0\" actually TRUNCATES the value! Not quite the same as flooring\n    // https://stackoverflow.com/questions/7487977/using-bitwise-or-0-to-floor-a-number\n    // Also, euclideanModulo(n, m) is the equivalent of (( n % m ) + m ) % m\n    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;\n    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;\n    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;\n\n    // Return index voxel is located at\n    return voxelY * cellSliceSize + voxelZ * cellSize + voxelX;\n  }\n\n  /**\n   * Computes the id of the cell stored as a key in this.cells based\n   * on the given x, y, and z coordinates of a voxel.\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   * @returns {string} The id of the cell in the form of \"(x,y,z)\"\n   */\n  computeCellId(x, y, z) {\n    const { cellSize } = this;\n    const cellX = Math.floor(x / cellSize);\n    const cellY = Math.floor(y / cellSize);\n    const cellZ = Math.floor(z / cellSize);\n    return `${cellX},${cellY},${cellZ}`;\n  }\n\n  /**\n   * Adds a new cell for a voxel at the given x, y, and z coordinates if a\n   * cell doesn't already exist to accomodate it.\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   * @returns {Uint8Array} Array of voxels for the cell\n   */\n  addCellForVoxel(x, y, z) {\n    // Get the id of the cell corresponding to the x, y, and z coordinate\n    const cellId = this.computeCellId(x, y, z);\n\n    // Get the array of voxels associated with the cellId\n    let cell = this.cells[cellId];\n\n    // If cell doesn't exist, add it\n    if (!cell) {\n      const { cellSize } = this;\n      cell = new Uint8Array(cellSize * cellSize * cellSize);\n      this.cells[cellId] = cell;\n    }\n\n    // Return the cell\n    return cell;\n  }\n\n  /**\n   * Finds the corresponding voxel array for the cell for the given voxel coordinates.\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   * @returns {Uint8Array} Array of voxels.\n   */\n  getCellForVoxel(x, y, z) {\n    return this.cells[this.computeCellId(x, y, z)];\n  }\n\n  /**\n   * Sets voxel at given coordinates.\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   * @param {number} v - The type of voxel to add\n   * @param {boolean} addCell - If true, a new cell will be created to accomodate the voxel if needed\n   */\n  setVoxel(x, y, z, v, addCell = true) {\n    // Get the array of voxels corresponding to the x, y, and z coordinates\n    let cell = this.getCellForVoxel(x, y, z);\n\n    // No cell was found\n    if (!cell) {\n      // If addCell is false, return\n      if (!addCell) {\n        return;\n      }\n      // Otherwise, create a new cell for the voxel\n      cell = this.addCellForVoxel(x, y, z);\n    }\n\n    // Find the index to add the new voxel within the found cell\n    const voxelOffset = this.computeVoxelOffset(x, y, z);\n\n    // Set the new voxel\n    cell[voxelOffset] = v;\n  }\n\n  /**\n   * Gets the corresponding voxel at the given coordinates.\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   * @returns {number} Number representing the type of voxel\n   */\n  getVoxel(x, y, z) {\n    // Find the cell that has the voxel at the given coordinates\n    const cell = this.getCellForVoxel(x, y, z);\n\n    // No such cell exists! Default by returning 0\n    if (!cell) {\n      return 0;\n    }\n\n    // Find the index of the voxel within the cell\n    const voxelOffset = this.computeVoxelOffset(x, y, z);\n\n    // Return the voxel that was found\n    return cell[voxelOffset];\n  }\n\n  /**\n   * Performs a flood fill starting at a given voxel position and sets that voxel and all voxels\n   * of the same type to the given v voxel type. If the voxel is obstructed by another voxel along\n   * the given normal, it is left untouched. Otherwise, it will be changed to the given v voxel type.\n   * If extruding, then adjacent empty voxels along the given normal will be changed to the given v\n   * voxel type instead.\n   * @param {number} startX - The x coordinate of the starting voxel\n   * @param {number} startY - The y coordinate of the starting voxel\n   * @param {number} startZ - The z coordinate of the starting voxel\n   * @param {number} normX - The x normal to check along\n   * @param {number} normY - The y normal to check along\n   * @param {number} normZ - The z normal to check along\n   * @param {number} v - The new voxel to flood fill with\n   * @param {boolean} isExtruding - If true, sets adjacent empty voxels along the normal to v.\n   * Otherwise, just changes adjacent voxels that share the same color of the starting voxel\n   */\n  floodFillVoxels(startX, startY, startZ, normX, normY, normZ, v, isExtruding) {\n    // Get the starting voxel\n    const startVoxel = this.getVoxel(startX, startY, startZ);\n\n    // No point in replacing voxel with itself, return\n    if (!isExtruding && startVoxel === v) return;\n\n    // Stack used to track which voxels needs to be set next. Start with given voxel\n    const stack = [{ x: startX, y: startY, z: startZ }];\n\n    // Continue to flood fill until stack is empty\n    while (stack.length) {\n      // Get the last voxel off the stack\n      const { x, y, z } = stack.pop();\n\n      // If it doesn't match the starting voxel or there's another voxel obstructing it, continue\n      if (\n        this.getVoxel(x, y, z) !== startVoxel ||\n        this.getVoxel(x + normX, y + normY, z + normZ) !== 0\n      ) {\n        continue;\n      }\n\n      // If extruding, set voxel in front along normal. Otherwise, replace current voxel\n      if (isExtruding) {\n        this.setVoxel(x + normX, y + normY, z + normZ, v);\n      } else {\n        this.setVoxel(x, y, z, v);\n      }\n\n      // Flood fill along x-axis\n      if (!normX) {\n        stack.push({ x: x + 1, y, z });\n        stack.push({ x: x - 1, y, z });\n      }\n\n      // Flood fill along y-axis\n      if (!normY) {\n        stack.push({ x, y: y + 1, z });\n        stack.push({ x, y: y - 1, z });\n      }\n\n      // Flood fill along z-axis\n      if (!normZ) {\n        stack.push({ x, y, z: z + 1 });\n        stack.push({ x, y, z: z - 1 });\n      }\n    }\n  }\n\n  /**\n   * Generates geometry data for a cell at the given coordinate. Similar to voxels, each cell\n   * is a part of a 3D grid as well.\n   * @example\n   * generateGeometryDataForCell(0, 0, 0);  // Cell created at (0, 0, 0) coordinate\n   * generateGeometryDataForCell(0, 1, 0);  // Cell created above the last one at (0, 1, 0)\n   *\n   * @param {number} cellX\n   * @param {number} cellY\n   * @param {number} cellZ\n   */\n  generateGeometryDataForCell(cellX, cellY, cellZ) {\n    const { cellSize, tileSize, tileTextureWidth, tileTextureHeight } = this;\n\n    // Used for generating the geometry of the final mesh formed by the voxels\n    const positions = [];\n    const normals = [];\n    const uvs = [];\n    const indices = [];\n    const colors = [];\n\n    // Calculate origin point of the cell i.e. (0, 0, 0)\n    const startX = cellX * cellSize;\n    const startY = cellY * cellSize;\n    const startZ = cellZ * cellSize;\n\n    // Iterate over y coords\n    for (let y = 0; y < cellSize; ++y) {\n      const voxelY = startY + y;\n      // Iterate over z coords\n      for (let z = 0; z < cellSize; ++z) {\n        const voxelZ = startZ + z;\n        // Iterate over x coords\n        for (let x = 0; x < cellSize; ++x) {\n          const voxelX = startX + x;\n\n          // Get voxel at current x, y, and z coords\n          const voxel = this.getVoxel(voxelX, voxelY, voxelZ);\n\n          // Check if voxel exists (by default, a voxel 0 is empty)\n          if (voxel) {\n            // voxel 0 is sky so for UVs we start at 0\n            const uvVoxel = voxel - 1;\n\n            // There is a voxel here but do we need faces for it?\n            for (const { dir, corners, uvRow } of VoxelWorld.faces) {\n              // The neighboring voxel to the face of our voxel\n              const neighbor = this.getVoxel(\n                voxelX + dir[0],\n                voxelY + dir[1],\n                voxelZ + dir[2]\n              );\n\n              // neighbor voxel is empty (0) in this direction so we need a face\n              if (!neighbor) {\n                // Used to define the indices\n                const ndx = positions.length / 3;\n\n                // Add vertices for the face of the voxel and normals too\n                for (const { pos, uv } of corners) {\n                  positions.push(pos[0] + x, pos[1] + y, pos[2] + z);\n                  normals.push(...dir);\n\n                  // TODO: uv's no longer being used. Might be added in the future though\n                  // Calculates where to grab texture from the texture atlas\n                  // uvVoxel corresponds to the column and uvRow the row to get the texture\n                  uvs.push(\n                    ((uvVoxel + uv[0]) * tileSize) / tileTextureWidth,\n                    1 - ((uvRow + 1 - uv[1]) * tileSize) / tileTextureHeight\n                  );\n\n                  // Add color. Subtract 1 for empty voxels do not correspond with palette array\n                  const color = this.colorPalette.getColorAtIndex(voxel - 1);\n                  colors.push(color.r, color.g, color.b);\n                }\n\n                // Add indices used to draw the face\n                indices.push(ndx, ndx + 1, ndx + 2, ndx + 2, ndx + 1, ndx + 3);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Return object consisting of geometry data for the voxel model\n    return {\n      positions,\n      normals,\n      uvs,\n      indices,\n      colors,\n    };\n  }\n\n  /**\n   * Algorithm for raycasting specialized for use with voxels. Used to check if the\n   * user clicked a voxel in the scene and returns information related to it such as\n   * the coordinates of the successful hit.\n   * The code itself is based upon this paper: http://www.cse.chalmers.se/edu/year/2010/course/TDA361/grid.pdf\n   * @param {*} start\n   * @param {*} end\n   * @returns {Object} HitResults or null if nothing was hit\n   * @returns {Array.<number>} HitResults.position Coordinates of the hit\n   * @returns {Array.<number>} HitResults.normal Normal of the hit\n   * @returns {number} HitResults.voxel The type of voxel hit\n   */\n  intersectRay(start, end) {\n    // Get the direction that ray is cast\n    let dx = end.x - start.x;\n    let dy = end.y - start.y;\n    let dz = end.z - start.z;\n\n    // Find the magnitude of the above direction\n    const lenSq = dx * dx + dy * dy + dz * dz;\n    const len = Math.sqrt(lenSq);\n\n    // Change to unit vector so we only have the direction of the ray cast\n    dx /= len;\n    dy /= len;\n    dz /= len;\n\n    // t is a scalar that we use to 'stretch' the ray into the scene to test for intersections\n    let t = 0.0;\n    let ix = Math.floor(start.x);\n    let iy = Math.floor(start.y);\n    let iz = Math.floor(start.z);\n\n    // Dictates how we 'step' from voxel to voxel\n    const stepX = dx > 0 ? 1 : -1;\n    const stepY = dy > 0 ? 1 : -1;\n    const stepZ = dz > 0 ? 1 : -1;\n\n    // The amount of change required to advance one whole voxel\n    const txDelta = Math.abs(1 / dx);\n    const tyDelta = Math.abs(1 / dy);\n    const tzDelta = Math.abs(1 / dz);\n\n    const xDist = stepX > 0 ? ix + 1 - start.x : start.x - ix;\n    const yDist = stepY > 0 ? iy + 1 - start.y : start.y - iy;\n    const zDist = stepZ > 0 ? iz + 1 - start.z : start.z - iz;\n\n    // location of nearest voxel boundary, in units of t\n    let txMax = txDelta < Infinity ? txDelta * xDist : Infinity;\n    let tyMax = tyDelta < Infinity ? tyDelta * yDist : Infinity;\n    let tzMax = tzDelta < Infinity ? tzDelta * zDist : Infinity;\n\n    // Represents the direction we last stepped in. Either x, y, or z\n    let steppedIndex = -1;\n\n    // main loop along raycast vector\n    while (t <= len) {\n      // Get the voxel at the ix, iy, and iz coordinate\n      const voxel = this.getVoxel(ix, iy, iz);\n\n      // Found a non-empty voxel! Return hit information\n      if (voxel) {\n        return {\n          position: [start.x + t * dx, start.y + t * dy, start.z + t * dz],\n          normal: [\n            steppedIndex === 0 ? -stepX : 0,\n            steppedIndex === 1 ? -stepY : 0,\n            steppedIndex === 2 ? -stepZ : 0,\n          ],\n          voxel,\n        };\n      }\n\n      // advance t to next nearest voxel boundary\n      // This is the core if-statement from the research paper\n      if (txMax < tyMax) {\n        if (txMax < tzMax) {\n          ix += stepX;\n          t = txMax;\n          txMax += txDelta;\n          steppedIndex = 0;\n        } else {\n          iz += stepZ;\n          t = tzMax;\n          tzMax += tzDelta;\n          steppedIndex = 2;\n        }\n      } else {\n        if (tyMax < tzMax) {\n          iy += stepY;\n          t = tyMax;\n          tyMax += tyDelta;\n          steppedIndex = 1;\n        } else {\n          iz += stepZ;\n          t = tzMax;\n          tzMax += tzDelta;\n          steppedIndex = 2;\n        }\n      }\n    }\n\n    // Nothing was found, return null\n    return null;\n  }\n\n  /**\n   * Updates the voxel of a cell at the given x, y, and z coordinates. Also,\n   * updates any cells that the voxel is adjacent to.\n   * @param scene - The scene to add the final mesh to\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   */\n  updateVoxelGeometry(scene, x, y, z) {\n    const updatedCellIds = {};\n\n    // Check the cell and all surrounding cells when updating voxel geometry\n    for (const offset of this.neighborOffsets) {\n      // Get the coordinates of the current cell to update\n      const ox = x + offset[0];\n      const oy = y + offset[1];\n      const oz = z + offset[2];\n\n      // Get the id of the cell we wish to update\n      const cellId = this.computeCellId(ox, oy, oz);\n\n      // If cell yet not updated, update it!\n      if (!updatedCellIds[cellId]) {\n        updatedCellIds[cellId] = true;\n\n        // Update the cell's geometry\n        this.updateCellGeometry(scene, ox, oy, oz);\n      }\n    }\n  }\n\n  /**\n   * Updates the geometry of the cell with the given coordinates within\n   * the scene.\n   * @param scene - The scene to add the final mesh to\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   */\n  updateCellGeometry(scene, x, y, z) {\n    const { cellSize } = this;\n\n    // Find the cell corresponding to the voxel at the x, y, and z coordinates\n    const cellX = Math.floor(x / cellSize);\n    const cellY = Math.floor(y / cellSize);\n    const cellZ = Math.floor(z / cellSize);\n    const cellId = this.computeCellId(x, y, z);\n\n    // Get the mesh corresponding to the given cellId\n    let mesh = this.cellIdToMesh[cellId];\n    // Get the geometry of the mesh. If no mesh exists, create new geometry\n    const geometry = mesh ? mesh.geometry : new THREE.BufferGeometry();\n\n    // Retrieve data for making the geometry for a given cell\n    const {\n      positions,\n      normals,\n      //uvs,\n      indices,\n      colors,\n    } = this.generateGeometryDataForCell(cellX, cellY, cellZ);\n\n    // Set position (vertex) data of cell\n    const positionNumComponents = 3;\n    geometry.setAttribute(\n      \"position\",\n      new THREE.BufferAttribute(\n        new Float32Array(positions),\n        positionNumComponents\n      )\n    );\n\n    // Set normal data for cell\n    const normalNumComponents = 3;\n    geometry.setAttribute(\n      \"normal\",\n      new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents)\n    );\n\n    // TODO: Add back if supporting textures\n    // Set uv data for cell\n    /*\n    const uvNumComponents = 2;\n    geometry.setAttribute(\n      \"uv\",\n      new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents)\n    );\n    */\n\n    const rgbNumComponents = 3;\n    geometry.setAttribute(\n      \"color\",\n      new THREE.BufferAttribute(new Float32Array(colors), rgbNumComponents)\n    );\n\n    // Set index data for cell\n    geometry.setIndex(indices);\n\n    // Comput bounding sphere of the geometry\n    geometry.computeBoundingSphere();\n\n    // If the mesh has not yet been created, create it!\n    if (!mesh) {\n      mesh = new THREE.Mesh(geometry, this.material);\n      mesh.name = cellId;\n      this.cellIdToMesh[cellId] = mesh;\n      scene.add(mesh);\n      mesh.position.set(cellX * cellSize, cellY * cellSize, cellZ * cellSize);\n    }\n  }\n\n  /**\n   * Updates every single cell within the world. Useful for when loading in\n   * a brand new world.\n   * @param {*} scene\n   */\n  updateWorldGeometry(scene) {\n    // Get an array of every cell's key\n    const cellKeys = Object.keys(this.cells);\n\n    // Regex used to extract cell position\n    let regex = /^(-?\\d+),(-?\\d+),(-?\\d+)$/;\n\n    // Update every cell\n    cellKeys.forEach((cellKey) => {\n      // Extract the x, y, and z position of the cell\n      let match = cellKey.match(regex);\n      const x = parseInt(match[1], 10);\n      const y = parseInt(match[2], 10);\n      const z = parseInt(match[3], 10);\n\n      // Update that cell\n      this.updateCellGeometry(\n        scene,\n        x * this.cellSize,\n        y * this.cellSize,\n        z * this.cellSize\n      );\n    });\n  }\n\n  /**\n   * Removes every cell from the world along with associated meshes.\n   * @param {Scene} scene The scene object to remove the cells from\n   */\n  removeAllCells(scene) {\n    // Free resources from each mesh\n    Object.keys(this.cellIdToMesh).forEach((cellId) => {\n      // TODO: check if material needs to be released as well\n      const mesh = this.cellIdToMesh[cellId];\n      mesh.geometry.dispose();\n      scene.remove(mesh);\n    });\n\n    this.cellIdToMesh = {};\n    this.cells = {};\n  }\n}\n\n/**\n * Array of objects that represent each face of a single voxel.\n * uvRow is the row of the texture atlas to grab an image from\n * dir is the direction of the face\n * corners consist of vertices and uv coordinates for the texture\n */\nVoxelWorld.faces = [\n  {\n    // left\n    uvRow: 0,\n    dir: [-1, 0, 0],\n    corners: [\n      { pos: [0, 1, 0], uv: [0, 1] },\n      { pos: [0, 0, 0], uv: [0, 0] },\n      { pos: [0, 1, 1], uv: [1, 1] },\n      { pos: [0, 0, 1], uv: [1, 0] },\n    ],\n  },\n  {\n    // right\n    uvRow: 0,\n    dir: [1, 0, 0],\n    corners: [\n      { pos: [1, 1, 1], uv: [0, 1] },\n      { pos: [1, 0, 1], uv: [0, 0] },\n      { pos: [1, 1, 0], uv: [1, 1] },\n      { pos: [1, 0, 0], uv: [1, 0] },\n    ],\n  },\n  {\n    // bottom\n    uvRow: 1,\n    dir: [0, -1, 0],\n    corners: [\n      { pos: [1, 0, 1], uv: [1, 0] },\n      { pos: [0, 0, 1], uv: [0, 0] },\n      { pos: [1, 0, 0], uv: [1, 1] },\n      { pos: [0, 0, 0], uv: [0, 1] },\n    ],\n  },\n  {\n    // top\n    uvRow: 2,\n    dir: [0, 1, 0],\n    corners: [\n      { pos: [0, 1, 1], uv: [1, 1] },\n      { pos: [1, 1, 1], uv: [0, 1] },\n      { pos: [0, 1, 0], uv: [1, 0] },\n      { pos: [1, 1, 0], uv: [0, 0] },\n    ],\n  },\n  {\n    // back\n    uvRow: 0,\n    dir: [0, 0, -1],\n    corners: [\n      { pos: [1, 0, 0], uv: [0, 0] },\n      { pos: [0, 0, 0], uv: [1, 0] },\n      { pos: [1, 1, 0], uv: [0, 1] },\n      { pos: [0, 1, 0], uv: [1, 1] },\n    ],\n  },\n  {\n    // front\n    uvRow: 0,\n    dir: [0, 0, 1],\n    corners: [\n      { pos: [0, 0, 1], uv: [0, 0] },\n      { pos: [1, 0, 1], uv: [1, 0] },\n      { pos: [0, 1, 1], uv: [0, 1] },\n      { pos: [1, 1, 1], uv: [1, 1] },\n    ],\n  },\n];\n\nexport default VoxelWorld;\n","/**\n * Brush object used to determine how to paint voxels on the scene.\n */\nclass Brush {\n  /**\n   * Creates a new brush object.\n   * @param {string} [action=\"add\"] Adding, removing, or painting voxels\n   * @param {string} [type=\"single\"] How to go about the actions\n   */\n  constructor(action = \"add\", type = \"single\") {\n    this.setCurrentAction(action);\n    this.setCurrentType(type);\n  }\n\n  // Options for each brush action\n  static brushActions = {\n    add: \"add\",\n    remove: \"remove\",\n    paint: \"paint\",\n  };\n\n  // Options for each brush type\n  static brushTypes = {\n    single: \"single\",\n    extrude: \"extrude\",\n  };\n\n  /**\n   * Gets the current brush action.\n   * @returns {string} The current action\n   */\n  getCurrentAction() {\n    return this.currentAction;\n  }\n\n  /**\n   * Sets the current brush action to one of the available brush options.\n   * @param {string} brushAction\n   */\n  setCurrentAction(brushAction) {\n    // Get the brush to set\n    const action = Brush.brushActions[brushAction];\n\n    // If that brush exists, set it as current\n    if (action) {\n      this.currentAction = action;\n    }\n  }\n\n  /**\n   * Gets the current brush type.\n   * @returns {string} The current type\n   */\n  getCurrentType() {\n    return this.currentType;\n  }\n\n  /**\n   * Sets the current brush type to one of the available brush types.\n   * @param {string} brushType\n   */\n  setCurrentType(brushType) {\n    // Get the brush type to set\n    const type = Brush.brushTypes[brushType];\n\n    // If that type exists, set it as current\n    if (type) {\n      this.currentType = type;\n    }\n  }\n}\n\nexport default Brush;\n","/**\n * Internal representation of the ColorPalette React component.\n * Used to track each color of the voxels within the scene.\n *\n * @property {Array.<Color>} colors - Array containing all of the colors in the color palette\n * @property {number} selectedColor - The currently selected color from the colors array\n * @property {number} maxColors - The maximum number of colors that the colors array can hold\n */\nclass ColorPalette {\n  /**\n   * Creates a new ColorPalette.\n   * @param {Array} [colors=null] Array of colors to create the color palette with\n   * @param {number} [selectedColor=0] The initial selected color\n   */\n  constructor(colors = null, selectedColor = 0) {\n    // Set the default values for member variables\n    this.colors = null;\n    this.selectedColor = 0;\n\n    // Initialize the color array\n    this.setNewColorsArray(\n      colors ? colors : [new Color(0.5176, 0.7843, 0.0902)]\n    );\n\n    // Set the currently selected color\n    this.setSelectedColor(selectedColor);\n\n    // The VoxelWorld can only hold up to 255 colors\n    this.maxColors = 128;\n  }\n\n  /**\n   * Sets the color palette to its default settings.\n   */\n  restoreDefaults() {\n    this.selectedColor = 0;\n    this.colors = [new Color(0.5176, 0.7843, 0.0902)];\n  }\n\n  /**\n   * Creates a new color array from the new one.\n   * @param {Array} newColors\n   */\n  setNewColorsArray(newColors) {\n    this.colors = newColors.map(({ r, g, b }) => new Color(r, g, b));\n  }\n\n  /**\n   * Adds a new color to the end of the colors array. Red by default.\n   * @param {number} [r = 1]\n   * @param {number} [g = 0]\n   * @param {number} [b = 0]\n   */\n  addColor(r = 1, g = 0, b = 0) {\n    if (!this.isColorsFull()) {\n      this.colors.push(new Color(r, g, b));\n      this.selectedColor = this.colors.length - 1;\n    }\n  }\n\n  /**\n   * Checks if the colors array is full. True if it is. False otherwise.\n   * @returns {boolean}\n   */\n  isColorsFull() {\n    return this.colors.length >= this.maxColors;\n  }\n\n  /**\n   * Sets the color at the given index to the given r, g, b values.\n   * @param {number} index\n   * @param {number} r\n   * @param {number} g\n   * @param {number} b\n   */\n  setColorAtIndex(index, r, g, b) {\n    // If index out of range, return\n    if (index < 0 || index >= this.colors.length) return;\n\n    // Set the rgb values of the color\n    this.colors[index].r = r;\n    this.colors[index].g = g;\n    this.colors[index].b = b;\n  }\n\n  /**\n   * Returns the color at the given index.\n   * @param {number} index\n   * @returns {Color} The color at the index. Null if not found\n   */\n  getColorAtIndex(index) {\n    // If index out of range, return\n    if (index < 0 || index >= this.colors.length) return null;\n    return this.colors[index];\n  }\n\n  /**\n   * Returns the currently selected color.\n   * @returns {Color}\n   */\n  getSelectedColor() {\n    return this.colors[this.selectedColor];\n  }\n\n  /**\n   * Changes the currently selected color to another within the colors array.\n   * @param {number} index\n   */\n  setSelectedColor(index) {\n    // If index out of range, return\n    if (index < 0 || index >= this.colors.length) return null;\n    this.selectedColor = index;\n  }\n\n  /**\n   * Returns the index of the selected color.\n   * @returns {number}\n   */\n  getSelectedColorIndex() {\n    return this.selectedColor;\n  }\n\n  /**\n   * Returns the array of colors currently in the palette.\n   * @returns {Array.Color}\n   */\n  getColorsArray() {\n    return this.colors;\n  }\n}\n\n/**\n * Class that represents a single rgb color with each component being from\n * 0 to 1.\n */\nclass Color {\n  constructor(r, g, b) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n  }\n\n  /**\n   * Returns a 0-255 value representation of the color.\n   * @returns {Object}\n   */\n  getRGB255() {\n    return { r: this.r * 255, g: this.g * 255, b: this.b * 255 };\n  }\n}\n\nexport default ColorPalette;\n","// Import Three.js\nimport * as THREE from \"three\";\n\n// Import orbit controls\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\n\n// Import Exporters\nimport { OBJExporter } from \"three/examples/jsm/exporters/OBJExporter\";\nimport { PLYExporter } from \"three/examples/jsm/exporters/PLYExporter\";\nimport { ColladaExporter } from \"three/examples/jsm/exporters/ColladaExporter\";\nimport { STLExporter } from \"three/examples/jsm/exporters/STLExporter\";\n\n// Import modules\nimport VoxelWorld from \"./VoxelWorld\";\nimport Brush from \"./Brush\";\nimport ColorPalette from \"./ColorPalette\";\n\n// Import FileSaver\nimport FileSaver from \"file-saver\";\n\n// Import image assets\n//import textureAtlas from \"../images/flourish-cc-by-nc-sa.png\";\n\n/**\n * Has the cell at the given coordinates form a flat ground out of its voxels.\n * @param {VoxelWorld} world - The world to spawn flat ground in\n * @param {number} cellX\n * @param {number} cellY\n * @param {number} cellZ\n * @param {number} cellSize - Dimensions of the cell\n * @param {number} [v=1] - The type of voxel to spawn.\n */\nfunction createFlatGround(world, cellX, cellY, cellZ, cellSize, v = 1) {\n  const startX = cellX * cellSize;\n  const startY = cellY * cellSize;\n  const startZ = cellZ * cellSize;\n\n  // Create flat ground with our voxels\n  for (let z = 0; z < cellSize; ++z) {\n    for (let x = 0; x < cellSize; ++x) {\n      world.setVoxel(startX + x, startY, startZ + z, v);\n    }\n  }\n}\n\n/*\n * TODO: Temporary function for creating the texture atlas. Will be removed\n * during the creation of the ColorPalette code.\n * @param {*} render\n * @return texture\n */\n/*\nfunction createTextureAtlas(render) {\n  // Load texture atlas\n  const loader = new THREE.TextureLoader();\n  const texture = loader.load(textureAtlas, render);\n  texture.magFilter = THREE.NearestFilter;\n  texture.minFilter = THREE.NearestFilter;\n  return texture;\n}\n*/\n\n/**\n * Class used to interface with the scene and handles the main render loop.\n */\nclass VoxelEditor {\n  constructor(options) {\n    this.canvas = options.canvas;\n    this.renderer = new THREE.WebGLRenderer({\n      canvas: this.canvas,\n      antialias: true,\n    });\n\n    // Length, width, and height of each cell in the VoxelWorld\n    this.cellSize = 32;\n\n    // Initialize the camera\n    this.createCamera();\n\n    // Initialize orbit controls\n    this.createOrbitControls();\n\n    // Create the scene\n    this.scene = new THREE.Scene();\n\n    // Setting background color to the same one Blender uses\n    this.scene.background = new THREE.Color(\"#3C3C3C\");\n\n    // Add two directional lights to the scene\n    this.addLight(-1, 2, 4);\n    this.addLight(1, -1, -2);\n\n    // TODO: Remove these variables soon. Not needed for ColorPalette\n    const tileSize = 16;\n    const tileTextureWidth = 256;\n    const tileTextureHeight = 64;\n    //const texture = createTextureAtlas(this.render);\n\n    // Create material for the voxel model\n    const material = new THREE.MeshLambertMaterial({\n      // TODO: add texture back if using textures\n      //map: texture,\n      side: THREE.DoubleSide,\n      alphaTest: 0.1,\n      transparent: true,\n      vertexColors: true,\n    });\n\n    // Load from previous world or set defaults\n    const { world } = options;\n    const colorPalette = world ? world.colorPalette : new ColorPalette();\n    const cells = world ? world.cells : {};\n\n    // Create a new VoxelWorld that will manage our voxels\n    this.world = new VoxelWorld({\n      cellSize: this.cellSize,\n      tileSize,\n      tileTextureWidth,\n      tileTextureHeight,\n      material,\n      colorPalette,\n      cells,\n    });\n\n    // If there is no pre-existing world, create flat ground by default\n    if (!world) {\n      // Create a floor to the world\n      createFlatGround(this.world, 0, 0, 0, this.cellSize, 1); // Center\n    }\n\n    // Update geometry of the entire world\n    this.world.updateWorldGeometry(this.scene);\n\n    // Used with requestRenderIfNotRequested() function\n    this.renderRequested = false;\n\n    // Mouse object representing the position of mouse clicks.\n    this.mouse = {\n      x: 0,\n      y: 0,\n      moveX: 0,\n      moveY: 0,\n    };\n\n    // Listen for mouse clicks\n    this.canvas.addEventListener(\n      \"pointerdown\",\n      (event) => {\n        event.preventDefault();\n        // Record where we first clicked\n        this.recordStartPosition(event);\n\n        // Record mouse movement\n        window.addEventListener(\"pointermove\", this.recordMovement);\n\n        // Add voxel upon releasing mouse click if movement is small. Other,\n        // user is orbiting the camera\n        window.addEventListener(\"pointerup\", this.placeVoxelIfNoMovement);\n      },\n      { passive: false }\n    );\n\n    // Listen for touch events\n    this.canvas.addEventListener(\n      \"touchstart\",\n      (event) => {\n        // prevent scrolling\n        event.preventDefault();\n      },\n      { passive: false }\n    );\n\n    // Listen for camera orbit events\n    this.controls.addEventListener(\"change\", this.requestRenderIfNotRequested);\n\n    // Listen for window resizing events\n    window.addEventListener(\"resize\", this.requestRenderIfNotRequested);\n\n    // Create new brush\n    this.brush = new Brush();\n\n    // Start render loop\n    this.render();\n  }\n\n  /**\n   * Helper function used to create the camera and set it to a default position.\n   * @param {number} [fov=75] - field of view\n   * @param {number} [aspect=2] - Aspect. Canvas default is 2\n   * @param {number} [near=0.1]\n   * @param {number} [far=1000]\n   */\n  createCamera(fov = 75, aspect = 2, near = 0.1, far = 1000) {\n    // Create a new perspective camera\n    this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n\n    // TODO: This is an arbitrary starting position. Consider an alternative\n    this.camera.position.set(\n      -this.cellSize * 0.2,\n      this.cellSize * 0.3,\n      -this.cellSize * 0.2\n    );\n  }\n\n  /**\n   * Helper function to create the orbit controls.\n   */\n  createOrbitControls() {\n    // Create the orbit controls\n    this.controls = new OrbitControls(this.camera, this.canvas);\n\n    // Orbit controls starts by targeting center of scene\n    this.controls.target.set(this.cellSize / 2, 0, this.cellSize / 2);\n\n    // Controls must be updated before they can be used\n    this.controls.update();\n  }\n\n  /**\n   * Adds a directional light to the scene at the given x, y, and z position.\n   * Remember, the default position of the directional light's target is (0, 0, 0).\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   */\n  addLight(x, y, z) {\n    const color = 0xffffff;\n    const intensity = 1;\n    const light = new THREE.DirectionalLight(color, intensity);\n    light.position.set(x, y, z);\n    this.scene.add(light);\n  }\n\n  /**\n   * Checks if the renderer needs to resize to account for changes in screen\n   * width or height.\n   * @param {WebGLRenderer} renderer\n   * @returns {boolean} True if the renderer resized. False otherwise.\n   */\n  resizeRendererToDisplaySize(renderer) {\n    const canvas = renderer.domElement;\n\n    const width = canvas.clientWidth;\n    const height = canvas.clientHeight;\n\n    const needResize = canvas.width !== width || canvas.height !== height;\n    if (needResize) {\n      renderer.setSize(width, height, false);\n    }\n    return needResize;\n  }\n\n  /**\n   * Main render loop.\n   * @function\n   */\n  render = () => {\n    this.renderRequested = undefined;\n\n    if (this.resizeRendererToDisplaySize(this.renderer)) {\n      this.camera.aspect = this.canvas.clientWidth / this.canvas.clientHeight;\n      this.camera.updateProjectionMatrix();\n    }\n\n    this.controls.update();\n    this.renderer.render(this.scene, this.camera);\n  };\n\n  /**\n   * Used to make a render update request only if one hasn't been made already.\n   * @function\n   */\n  requestRenderIfNotRequested = () => {\n    if (!this.renderRequested) {\n      this.renderRequested = true;\n      requestAnimationFrame(this.render);\n    }\n  };\n\n  /**\n   * Finds the x and y coordinate of a mouse click relative to the canvas.\n   * @param {Event} event\n   * @returns {Object} Object with x and y coordinates of click relative to canvas\n   */\n  getCanvasRelativePosition(event) {\n    const { canvas } = this;\n    const rect = canvas.getBoundingClientRect();\n\n    // Calculate the x and y of click relative to the canvas\n    return {\n      x: ((event.clientX - rect.left) * canvas.width) / rect.width,\n      y: ((event.clientY - rect.top) * canvas.height) / rect.height,\n    };\n  }\n\n  /**\n   * Handler for adding, removing, or painting a voxel based on the given brush\n   * and where the user clicked.\n   * @param {Event} event\n   */\n  placeVoxel(event) {\n    // Find position of mouse click relative to canvas\n    const pos = this.getCanvasRelativePosition(event);\n    const x = (pos.x / this.canvas.width) * 2 - 1;\n    const y = (pos.y / this.canvas.height) * -2 + 1; // note we flip Y\n\n    // Get the starting and ending vectors for our raycast\n    const start = new THREE.Vector3();\n    const end = new THREE.Vector3();\n    start.setFromMatrixPosition(this.camera.matrixWorld);\n    end.set(x, y, 1).unproject(this.camera);\n\n    // Cast a ray into the scene\n    const intersection = this.world.intersectRay(start, end);\n\n    // If raycast wasn't successful, return\n    if (!intersection) return;\n\n    // Add voxels depending on the current brush type\n    switch (this.brush.currentType) {\n      // Single type brush\n      case Brush.brushTypes.single:\n        this.singleBrushAction(intersection);\n        break;\n\n      // Extrude type brush\n      case Brush.brushTypes.extrude:\n        this.extrudeBrushAction(intersection);\n        break;\n\n      default:\n      // No default case\n    }\n  }\n\n  /**\n   * Perform the current brush action for the single brush type.\n   * For add, add a single voxel.\n   * For remove, remove a single voxel.\n   * For paint, paint a single voxel.\n   * @param {Object} intersection\n   */\n  singleBrushAction = (intersection) => {\n    // Set voxelId depending on brush option. 0 removes voxels\n    const voxelId =\n      this.brush.currentAction === Brush.brushActions.remove\n        ? 0\n        : this.world.colorPalette.getSelectedColorIndex() + 1;\n\n    // the intersection point is on the face. That means\n    // the math imprecision could put us on either side of the face.\n    // so go half a normal into the voxel if removing/painting\n    // or half a normal out if adding\n    const pos = intersection.position.map((v, ndx) => {\n      return (\n        v +\n        intersection.normal[ndx] *\n          (this.brush.currentAction === Brush.brushActions.add ? 0.5 : -0.5)\n      );\n    });\n\n    // Set voxel at the pos position with new voxelID\n    this.world.setVoxel(...pos, voxelId);\n\n    // Update the cell associated with the position of the new voxel\n    this.world.updateVoxelGeometry(this.scene, ...pos);\n\n    // Update render frame\n    this.requestRenderIfNotRequested();\n  };\n\n  /**\n   * Perform the current brush action for the extrude brush type.\n   * For add, place a layer of voxels on all adjacent voxels of the same color along\n   * the clicked side.\n   * For remove, remove a layer of adjacent voxels of the same color along the clicked side.\n   * For paint, paint a layer of adjacent voxels of the same color along the clicked side.\n   * @param {Object} intersection\n   */\n  extrudeBrushAction = (intersection) => {\n    // Set voxelId depending on brush option. 0 removes voxels\n    const voxelId =\n      this.brush.currentAction === Brush.brushActions.remove\n        ? 0\n        : this.world.colorPalette.getSelectedColorIndex() + 1;\n\n    // Get position of voxel that was intersected\n    const pos = intersection.position.map((v, ndx) => {\n      // Return the position of the voxel that was clicked\n      return v + intersection.normal[ndx] * -0.5;\n    });\n\n    // True if adding more geometry\n    const isExtruding = this.brush.currentAction === Brush.brushActions.add;\n\n    // Extrude the voxels or just re-paint voxels of the same type if not extruding\n    this.world.floodFillVoxels(\n      ...pos,\n      ...intersection.normal,\n      voxelId,\n      isExtruding\n    );\n\n    // Update world geometry\n    // @TODO: Find a way to only update cells that need an update instead of everything\n    // As an idea, maybe world should have an \"out of date\" variable for cells?\n    this.world.updateWorldGeometry(this.scene);\n\n    // Update render frame\n    this.requestRenderIfNotRequested();\n  };\n\n  /**\n   * Reset mouse movement and begin recording.\n   * @function\n   * @param {Event} event\n   */\n  recordStartPosition = (event) => {\n    const { mouse } = this;\n    mouse.x = event.clientX;\n    mouse.y = event.clientY;\n    mouse.moveX = 0;\n    mouse.moveY = 0;\n  };\n\n  /**\n   * Callback function used to record how far the mouse has moved since started recording.\n   * @function\n   * @param {Event} event\n   */\n  recordMovement = (event) => {\n    const { mouse } = this;\n    mouse.moveX += Math.abs(mouse.x - event.clientX);\n    mouse.moveY += Math.abs(mouse.y - event.clientY);\n  };\n\n  /**\n   * Callback function used to check if the user meant to set a voxel instead\n   * of orbiting the camera.\n   * @function\n   * @param {Event} event\n   */\n  placeVoxelIfNoMovement = (event) => {\n    const { mouse } = this;\n    // Mouse hardly moved, user likely intended to place a voxel\n    if (mouse.moveX < 5 && mouse.moveY < 5) {\n      this.placeVoxel(event);\n    }\n\n    // Stop recording movement and checks to place voxel\n    window.removeEventListener(\"pointermove\", this.recordMovement);\n    window.removeEventListener(\"pointerup\", this.placeVoxelIfNoMovement);\n  };\n\n  /**\n   * Called whenever a new color is selected.\n   * @function\n   * @param {number} index - Index of the changed color\n   * @param {r} r - Red color from 0-1\n   * @param {g} g - Green color from 0-1\n   * @param {b} b - Blue color from 0-1\n   */\n  onSelectedColorChange = (index, r, g, b) => {\n    // Update the color\n    this.world.colorPalette.setColorAtIndex(index, r, g, b);\n\n    // Updated the world with new color\n    this.world.updateWorldGeometry(this.scene);\n\n    // Update render frame\n    this.requestRenderIfNotRequested();\n  };\n\n  /**\n   * Updates which voxel the user is placing/painting now from the palette.\n   * @function\n   * @param {number} index\n   */\n  onNewSelectedColor = (index) => {\n    // Update the currently selected color for adding/painting\n    this.world.colorPalette.setSelectedColor(index);\n  };\n\n  /**\n   * Gets project data from the currently open project.\n   * @function\n   * @returns {Object} JavaScript object representing the relevant data from the\n   * currently open project/scene.\n   */\n  onGetProjectData = () => {\n    const projectObj = {\n      voxelWorld: {\n        cellSize: this.world.cellSize,\n        cells: this.world.cells,\n      },\n      colorPalette: {\n        colors: this.world.colorPalette.getColorsArray(),\n        selectedColor: this.world.colorPalette.getSelectedColorIndex(),\n      },\n    };\n\n    return projectObj;\n  };\n\n  /**\n   * Loads a project from the given data.\n   * @function\n   * @param {Object} projectData\n   */\n  onLoadProjectData = (projectData) => {\n    const { voxelWorld, colorPalette } = projectData;\n\n    // Remove the old cells from the world\n    this.world.removeAllCells(this.scene);\n\n    // Load data for the color palette\n    this.world.colorPalette.setNewColorsArray(colorPalette.colors);\n    this.world.colorPalette.setSelectedColor(colorPalette.selectedColor);\n\n    // Load data for the VoxelWorld\n    this.world.cells = voxelWorld.cells;\n    this.world.cellSize = voxelWorld.cellSize;\n\n    // Update world geometry and rerender\n    this.world.updateWorldGeometry(this.scene);\n    this.requestRenderIfNotRequested();\n  };\n\n  /**\n   * Exports the current frame of the canvas to an image file.\n   * @function\n   * @param {string} imageName\n   */\n  onExportImage = (imageName) => {\n    // Render must first be invoked to get current frame\n    this.render();\n\n    // Save the current frame as an image\n    this.canvas.toBlob((blob) => {\n      FileSaver.saveAs(blob, imageName + \".png\");\n    }, \"image/png\");\n  };\n\n  /**\n   * Exports the voxel model to some 3D file format\n   * @function\n   * @param {string} name - What the exported file should be called\n   * @param {string} type - The type of file to export\n   */\n  onExportModel = (name, type) => {\n    // Create an exporter that matches the given type\n    let exporter, blobType;\n    switch (type) {\n      case \"obj\":\n        exporter = new OBJExporter();\n        blobType = \"model/obj\";\n        break;\n\n      case \"ply\":\n        exporter = new PLYExporter();\n        // ply doesn't appear to have an official internet media type\n        blobType = \"text/plain\";\n        break;\n\n      case \"stl\":\n        exporter = new STLExporter();\n        blobType = \"model/stl\";\n        break;\n\n      case \"dae\":\n        exporter = new ColladaExporter();\n        blobType = \"model/vnd.collada+xml\";\n        break;\n\n      default:\n        exporter = null;\n        break;\n    }\n\n    // If type is invalid, return\n    if (!exporter) return;\n\n    // Parse the scene for object data\n    const result = exporter.parse(this.scene);\n\n    // Create a blob to download with object data\n    const blob = new Blob([result], {\n      type: blobType,\n    });\n\n    // Save object file to user's device\n    FileSaver.saveAs(blob, name + \".\" + type);\n  };\n\n  /**\n   * Creates a new, empty voxel world\n   * @function\n   */\n  onNewProject = () => {\n    this.world.removeAllCells(this.scene);\n    this.world.colorPalette.restoreDefaults();\n    createFlatGround(this.world, 0, 0, 0, this.cellSize, 1); // Center\n\n    // Update geometry of the entire world\n    this.world.updateWorldGeometry(this.scene);\n\n    this.requestRenderIfNotRequested();\n  };\n}\n\nexport default VoxelEditor;\n","import React from \"react\";\nimport GUIController from \"./GUIController\";\nimport VoxelEditor from \"../modules/VoxelsEditor\";\n\n/**\n * The main driving component for the application. Sets up the rest of\n * the user interface and directly communicates with the Voxel.js module.\n * @extends React.Component\n */\nclass VoxelManager extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // The VoxelEditor itself that handles the 3D scene\n    this.voxelEditor = null;\n\n    // Create object with callbacks for each component\n    this.callbacks = this.getCallbacksObject();\n  }\n\n  /**\n   * Takes the given canvas Ref and renders the voxel world.\n   * @function\n   * @param {Ref} canvasRef\n   */\n  createVoxelWorld = (canvasRef) => {\n    if (!canvasRef) return;\n\n    if (!this.voxelEditor) {\n      this.voxelEditor = new VoxelEditor({ canvas: canvasRef.current });\n    } else {\n      const world = this.voxelEditor.world;\n      this.voxelEditor = new VoxelEditor({ canvas: canvasRef.current, world });\n    }\n  };\n\n  /**\n   * Changes the brush action currently being used.\n   * @function\n   * @param {string} brushAction - brush action to set\n   */\n  setBrushAction = (brushAction) => {\n    if (this.voxelEditor) {\n      this.voxelEditor.brush.setCurrentAction(brushAction);\n    }\n  };\n\n  /**\n   * Handler for when Brush components want to know the current\n   * brush action in the editor.\n   * @returns {string} The current brush action\n   */\n  onGetBrushAction = () => {\n    if (!this.voxelEditor) {\n      return \"add\";\n    }\n\n    return this.voxelEditor.brush.getCurrentAction();\n  };\n\n  /**\n   * Changes the brush type currently being used.\n   * @function\n   * @param {string} brushType\n   */\n  setBrushType = (brushType) => {\n    if (this.voxelEditor) {\n      this.voxelEditor.brush.setCurrentType(brushType);\n    }\n  };\n\n  /**\n   * Handler for when Brush components want to know the current\n   * brush type in the editor.\n   * @returns {string} The current brush type\n   */\n  onGetBrushType = () => {\n    if (!this.voxelEditor) {\n      return \"single\";\n    }\n\n    return this.voxelEditor.brush.getCurrentType();\n  };\n\n  /**\n   * Returns color palette data from the VoxelWorld.\n   * @function\n   * @returns {Array.Color}\n   */\n  onGetColorData = () => {\n    // Return empty array if voxelEditor not ready\n    if (!this.voxelEditor) {\n      return {\n        colors: [],\n        selectedColorIndex: 0,\n        currentColor: { r: 127.5, g: 127.5, b: 127.5 }, // default to a grey color\n        isColorsFull: true,\n      };\n    }\n\n    const { colorPalette } = this.voxelEditor.world;\n    const { r, g, b } = colorPalette.getSelectedColor().getRGB255();\n    return {\n      colors: colorPalette.getColorsArray(),\n      selectedColorIndex: colorPalette.getSelectedColorIndex(),\n      currentColor: { r, g, b },\n      isColorsFull: colorPalette.isColorsFull(),\n    };\n  };\n\n  /**\n   * Called whenever a new color is selected.\n   * @function\n   * @param {number} index - Index of the changed color\n   * @param {Object} color\n   */\n  onSelectedColorChange = (index, color) => {\n    if (this.voxelEditor) {\n      const { r, g, b } = color;\n\n      // Adjust the color to be on a 0-1 range\n      this.voxelEditor.onSelectedColorChange(index, r / 255, g / 255, b / 255);\n    }\n  };\n\n  /**\n   * Tells the VoxelEditor what color of voxel the user is placing/painting now.\n   * @function\n   * @param {number} index\n   */\n  onNewSelectedColor = (index) => {\n    if (this.voxelEditor) {\n      this.voxelEditor.onNewSelectedColor(index);\n    }\n  };\n\n  /**\n   * Tell the VoxelEditor that the user added a new color to their color palette\n   * @function\n   */\n  onAddColor = () => {\n    if (!this.voxelEditor) return;\n\n    // Add a new color to the color palette\n    this.voxelEditor.world.colorPalette.addColor();\n  };\n\n  /**\n   * Gets project data from the currently open project.\n   * @function\n   * @returns {Object} JavaScript object representing the relevant data from the\n   * currently open project/scene.\n   */\n  onGetProjectData = () => {\n    // If voxelEditor isn't ready, return an empty object\n    if (!this.voxelEditor) return {};\n\n    // Return object representing the currently open project\n    return this.voxelEditor.onGetProjectData();\n  };\n\n  /**\n   * Handler used to load a new scene from the given project data.\n   * @function\n   * @param {Object} projectData\n   */\n  onLoadProjectData = (projectData) => {\n    // If voxelEditor isn't ready, do nothing\n    if (!this.voxelEditor) return;\n\n    // Load the project\n    this.voxelEditor.onLoadProjectData(projectData);\n\n    // @TODO: Generally, you should never invoke this method.\n    // Since loading a project leads to a substantial change in the application's\n    // internal state, I am making an exception.\n    this.forceUpdate();\n  };\n\n  /**\n   * Handler used to export the current frame from the canvas as an image.\n   * @function\n   * @param {string} imageName - What to name the exported image\n   * @returns {Canvas} The canvas to take a screenshot from\n   */\n  onExportImage = (imageName) => {\n    if (!this.voxelEditor) return null;\n\n    this.voxelEditor.onExportImage(imageName);\n  };\n\n  /**\n   * Exports the voxel model to some 3D file format.\n   * @function\n   * @param {string} name - What the exported file should be called\n   * @param {string} type - The type of file to export\n   */\n  onExportModel = (name, type) => {\n    if (!this.voxelEditor) return;\n\n    this.voxelEditor.onExportModel(name, type);\n  };\n\n  /**\n   * Loads a fresh, blank project.\n   * @function\n   */\n  onNewProject = () => {\n    if (!this.voxelEditor) return;\n\n    this.voxelEditor.onNewProject();\n    this.forceUpdate();\n  };\n\n  /**\n   * Returns callbacks organized by the component that they are meant for.\n   * @function\n   * @returns {Object}\n   */\n  getCallbacksObject = () => {\n    return {\n      brush: {\n        brushActions: {\n          onBrushActionChange: this.setBrushAction,\n          onGetBrushAction: this.onGetBrushAction,\n        },\n        brushTypes: {\n          onBrushTypeChange: this.setBrushType,\n          onGetBrushType: this.onGetBrushType,\n        },\n      },\n      colorPalette: {\n        onGetColorData: this.onGetColorData,\n        onSelectedColorChange: this.onSelectedColorChange,\n        onNewSelectedColor: this.onNewSelectedColor,\n        onAddColor: this.onAddColor,\n      },\n      viewport: {\n        onCanvasCreation: this.createVoxelWorld,\n      },\n      file: {\n        onGetProjectData: this.onGetProjectData,\n        onLoadProjectData: this.onLoadProjectData,\n        onExportModel: this.onExportModel,\n        onNewProject: this.onNewProject,\n      },\n      render: {\n        onExportImage: this.onExportImage,\n      },\n      examples: {\n        onLoadProjectData: this.onLoadProjectData,\n      },\n    };\n  };\n\n  render() {\n    return <GUIController callbacks={this.callbacks} />;\n  }\n}\n\nexport default VoxelManager;\n","import \"./App.css\";\nimport VoxelManager from \"./VoxelManager\";\n\nconst App = () => {\n  return <VoxelManager />;\n};\n\nexport default App;\n","import \"semantic-ui-css/semantic.min.css\";\nimport \"./ColorVariables.css\";\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./components/App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}